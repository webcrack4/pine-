//@version=5
indicator("v5 combination by yzz", "MACD-X ʙʏ DGT ☼☾", true, max_lines_count = 500, max_boxes_count = 250, max_bars_back = 500)

macdType      = input.string("MACD-SOURCE", "MACD Calculation Method", options=["MACD-TRADITIONAL", "MACD-AS (HISTOGRAM)", "MACD-LEADER", "MACD-SOURCE"])
fast_length   = input.int(12, "Fast Length", minval = 1)
slow_length   = input.int(26, "Slow Length", minval = 1)
source        = input(close, "Source")
signal_length = input.int(9, "Signal Smoothing",  minval = 1, maxval = 50)
sma_source    = input.string("EMA", "Oscillator MA Type" , options=["SMA", "EMA"])
sma_signal    = input.string("EMA", "Signal Line MA Type", options=["SMA", "EMA"])
macdSigCross  = input.bool(false, "Display MACD/Signal Corsses")
highlight     = input.bool(true, "Highlight MACD/Signal Area")
lookbackLength= input.int(200, 'Overlay Indicator Display Length', minval = 10, maxval = 250) 
oscPlacement  = input.string('Bottom', 'Placement', options = ['Top', 'Bottom'], inline='VOL')
oscHight      = 12 - input.int(10, 'Hight' , minval = 1, maxval = 10  , inline='VOL' )
verticalAdj   = input.int(4, "Vertical Indicator Position", minval = 0, maxval = 10) / 10

ma(s, l, m) => m == "EMA" ? ta.ema(s, l) : ta.sma(s, l)

fast_ma = ma(source, fast_length, sma_source)
slow_ma = ma(source, slow_length, sma_source)
macd    = fast_ma - slow_ma

macd := if macdType == "MACD-TRADITIONAL"
    macd
else if macdType == "MACD-AS (HISTOGRAM)"
    macd - ma(macd, signal_length, sma_source)
else if macdType == "MACD-LEADER"
    macd + ma(source - fast_ma, fast_length, sma_source) - ma(source - slow_ma, slow_length, sma_source)
else
    ma(source - math.avg(fast_ma, slow_ma), signal_length, sma_source)

signal = ma(macd, signal_length, sma_signal)
hist   = macd - signal

longAlertCondition  = ta.crossover(macd, signal)
alertcondition(longAlertCondition   , "Long : Early Warning"        , "MACD-X - Not Confirmed Probable Long Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}")
alertcondition(longAlertCondition[1], "Long : Trading Opportunity"  , "MACD-X - Probable Long Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}")
plotshape(macdSigCross ? longAlertCondition : na, "Long" , shape.labelup  , location.belowbar, color.new(color.green, 0), size=size.small , show_last=lookbackLength)

shortAlertCondition = ta.crossunder(macd, signal)
alertcondition(shortAlertCondition   , "Short : Early Warning"      , "MACD-X - Not Confirmed Probable Short Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}")
alertcondition(shortAlertCondition[1], "Short : Trading Opportunity", "MACD-X - Probable Short Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}")
plotshape(macdSigCross ? shortAlertCondition : na, "Short", shape.labeldown, location.abovebar, color.new(color.red  , 0), size=size.small , show_last=lookbackLength)

var a_lines     = array.new_line()
var a_hist      = array.new_box()
var a_fill      = array.new_linefill()

priceHighest    = ta.highest(high, lookbackLength)
priceLowest     = ta.lowest (low , lookbackLength)
priceChangeRate = (priceHighest - priceLowest) / priceHighest
priceLowest    := priceLowest  * (1 - priceChangeRate * verticalAdj)
priceHighest   := priceHighest * (1 + priceChangeRate * verticalAdj)
oscHighest      = ta.highest(macd, lookbackLength)
histColor       = hist >= 0 ? hist[1] < hist ? #006400 : color.green : hist[1] < hist ? color.red : #910000

if barstate.islast
    if array.size(a_lines) > 0
        for i = 1 to array.size(a_lines)
            line.delete(array.shift(a_lines))

    if array.size(a_hist) > 0
        for i = 1 to array.size(a_hist)
            box.delete(array.shift(a_hist))

    if array.size(a_fill) > 0
        for i = 1 to array.size(a_fill)
            linefill.delete(array.shift(a_fill))

    hightAdj = priceChangeRate / oscHight

    for barIndex = 0 to lookbackLength - 1
        if array.size(a_lines) < 501
            array.push(a_hist , box.new (bar_index[barIndex],      oscPlacement == 'Top' ? priceHighest : priceLowest, 
                                         bar_index[barIndex],     (oscPlacement == 'Top' ? priceHighest : priceLowest) * (1 + hist[barIndex]       / oscHighest * hightAdj), histColor[barIndex], 2))
            array.push(a_lines, line.new(bar_index[barIndex],     (oscPlacement == 'Top' ? priceHighest : priceLowest) * (1 + macd[barIndex]       / oscHighest * hightAdj), 
                                         bar_index[barIndex + 1], (oscPlacement == 'Top' ? priceHighest : priceLowest) * (1 + macd[barIndex + 1]   / oscHighest * hightAdj), xloc.bar_index, extend.none, #2962FF, line.style_solid, 1))
            array.push(a_lines, line.new(bar_index[barIndex],     (oscPlacement == 'Top' ? priceHighest : priceLowest) * (1 + signal[barIndex]     / oscHighest * hightAdj), 
                                         bar_index[barIndex + 1], (oscPlacement == 'Top' ? priceHighest : priceLowest) * (1 + signal[barIndex + 1] / oscHighest * hightAdj), xloc.bar_index, extend.none, #FF6D00, line.style_solid, 1))
            if highlight
                array.push(a_fill, linefill.new(array.get(a_lines, 2 * barIndex), array.get(a_lines, 2 * barIndex + 1), macd[barIndex] > signal[barIndex] ? color.new(#2962FF, 50) : color.new(#FF6D00, 50)))

var table logo = table.new(position.bottom_right, 1, 1)
if barstate.islast
    table.cell(logo, 0, 0, '☼☾  ', text_size=size.normal, text_color=color.teal)





//////////////////////////////////////////////////////
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////







length = input.int(10, "Trend Length")
target = input.int(0, "Set Targets")
// }


// ＶＡＲＩＡＢＬＥＳ ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
var bool tttrend    = na
float trend_value = na

// Colors
color up_color = #06b690
color dn_color = color.rgb(182, 112, 6)

// ATR for calculating stop loss and target levels
series float atr_value = ta.sma(ta.atr(200), 200) * 0.8

// Moving averages for tttrend detection
series float sma_high  = ta.sma(high, length) + atr_value
series float sma_low   = ta.sma(low, length) - atr_value
color       plot_color = color.new(chart.fg_color, 80)

// UDT for managing lines and labels
type TrendTargets
    line[] lines
    label[] labels

// Initialize UDT
var TrendTargets targets_up   = TrendTargets.new(array.new_line(), array.new_label())
var TrendTargets targets_down = TrendTargets.new(array.new_line(), array.new_label())
// }


// ＣＡＬＣＵＬＡＴＩＯＮＳ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
  
// Determine tttrend based on crossovers
if ta.crossover(close, sma_high) and barstate.isconfirmed
    tttrend := true
if ta.crossunder(close, sma_low) and barstate.isconfirmed
    tttrend := false

trend_value := switch
    tttrend     => sma_low
    not tttrend => sma_high

trend_color = tttrend ? up_color : not tttrend ? dn_color : na


// Signal detection for tttrend changes
bool signal_up   = ta.change(tttrend) and not tttrend[1]
bool signal_down = ta.change(tttrend) and tttrend[1]


// Method to draw tttrend targets and manage lines/labels
method draw_targets(TrendTargets targets, bool signal1, bool signal2, bool direction)=>
    float base           = direction ? sma_low : sma_high
    float atr_multiplier = atr_value * (direction ? 1 : -1)

    // Reset counters for up and down targets
    var int count_up   = 0
    var int count_down = 0

    if tttrend 
        count_down := 0
        count_up += 1
    if not tttrend 
        count_down += 1
        count_up := 0

    int count = direction ? count_up : count_down

    if signal1
        float target_len1 = atr_multiplier * (5+target)
        float target_len2 = atr_multiplier * (10+target*2)
        float target_len3 = atr_multiplier * (15+target*3)
                
        // Clear existing lines and labels
        for line_i in targets.lines
            int i = targets.lines.indexof(line_i)
            label.delete(targets.labels.get(i))
            line.delete(line_i)

        array.clear(targets.lines)
        array.clear(targets.labels)

        // Draw new lines for tttrend targets
        line stop_loss_line = line.new(bar_index, base, bar_index + 20, base)
        line entry_line     = line.new(bar_index, close, bar_index + 20, close)
        line target1_line   = line.new(bar_index, close + target_len1, bar_index + 20, close + target_len1)
        line target2_line   = line.new(bar_index, close + target_len2, bar_index + 20, close + target_len2)
        line target3_line   = line.new(bar_index, close + target_len3, bar_index + 20, close + target_len3)

        // Fill between stop loss and entry line
        linefill.new(stop_loss_line, entry_line, color.new(dn_color, 95))
        linefill.new(entry_line, target3_line, color.new(up_color, 95))

        // Draw new labels for tttrend targets
        label stop_loss_label = label.new(bar_index + 20, base, str.tostring(math.round(base, 2)))
        label entry_label     = label.new(bar_index + 20, close, str.tostring(math.round(close, 2)))
        label target1_label   = label.new(bar_index + 20, close + target_len1, "１ - " + str.tostring(math.round(close + target_len1, 2)))
        label target2_label   = label.new(bar_index + 20, close + target_len2, "２ - " + str.tostring(math.round(close + target_len2, 2)))
        label target3_label   = label.new(bar_index + 20, close + target_len3, "３ - " + str.tostring(math.round(close + target_len3, 2)))

        // Push lines and labels to the UDT
        targets.lines.push(stop_loss_line)
        targets.lines.push(entry_line)
        targets.lines.push(target1_line)
        targets.lines.push(target2_line)
        targets.lines.push(target3_line)

        targets.labels.push(stop_loss_label)
        targets.labels.push(entry_label)
        targets.labels.push(target1_label)
        targets.labels.push(target2_label)
        targets.labels.push(target3_label)

        // Update styles for labels and lines
        for lbl in targets.labels
            int  idx      = targets.labels.indexof(lbl)
            line line_ref = targets.lines.get(idx)
            lbl.set_style(label.style_label_left)
            lbl.set_color(chart.fg_color)
            lbl.set_textcolor(chart.bg_color)
            line_ref.set_color(chart.fg_color)

    if signal2
        // Clear existing lines and labels
        for line_i in targets.lines
            int i = targets.lines.indexof(line_i)
            label.delete(targets.labels.get(i))
            line.delete(line_i)

        array.clear(targets.lines)
        array.clear(targets.labels)

    for line_i in targets.lines
        int   idx           = targets.lines.indexof(line_i)
        label lbl_ref       = targets.labels.get(idx)
        label first_label   = targets.labels.first()
        line  entry_line    = targets.lines.get(1)
        label entry_label   = targets.labels.get(1)

        // Targets
        if high >= line.get_y2(line_i) and low <= line.get_y2(line_i) and count > 1
            lbl_ref.set_style(label.style_label_left)
            lbl_ref.set_color(chart.fg_color)
            lbl_ref.set_text("   ✔   ")
            lbl_ref.set_textcolor(#16ac09)
            line_i.set_style(line.style_dashed)
            line_i.set_color(plot_color)

        // Stop Loss
        if high >= line.get_y2(targets.lines.first()) and low <= line.get_y2(targets.lines.first()) and count > 1
            first_label.set_text("  ✖  ")

        if direction ? tttrend : not tttrend
            first_label.set_textcolor(#db1e1e)
            line_i.set_x2(bar_index + 20)
            targets.lines.first().set_color(#db1e1e)
            
            label.set_x(targets.labels.get(idx), bar_index + 20)

            entry_line.set_style(line.style_solid)
            entry_line.set_color(up_color)
            entry_label.set_text("◉ " + str.tostring(math.round(line.get_y2(entry_line), 2)))
            entry_label.set_textcolor(#1d80dd)
// }

// ＰＬＯＴ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
// Call the draw_targets method for both upward and downward trends
targets_down.draw_targets(signal_down, signal_up, false)
targets_up.draw_targets(signal_up, signal_down, true)

// Plot candlesticks with tttrend color
plotcandle(open, high, low, close,
           title = 'Title', 
           color = trend_color,
           wickcolor = trend_color, 
           bordercolor = trend_color)

// Plot trailing stops
p1 = plot(tttrend ? trend_value : na, style = plot.style_linebr, color = plot_color)
p2 = plot(not tttrend ? trend_value : na, style = plot.style_linebr, color = plot_color)
p0 = plot(hl2, display = display.none, editable = false)
fill(p1, p0, trend_value, hl2, color.new(chart.fg_color, 90), na)
fill(p2, p0, trend_value, hl2, color.new(chart.fg_color, 90), na)

// Plot signals on the chart
float sigUp = signal_up ? low - atr_value*2 : na
float sigDn = signal_down ? high + atr_value*2 : na

plotshape(sigUp,   "", shape.triangleup, location.absolute, up_color, size = size.tiny)
plotshape(sigUp,   "", shape.triangleup, location.absolute, color.new(up_color, 80), size = size.small)

plotshape(sigDn, "", shape.triangledown, location.absolute, dn_color, size = size.tiny)
plotshape(sigDn, "", shape.triangledown, location.absolute, color.new(dn_color, 80), size = size.small)

// }










//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////



// --------------------------------------------------------------------------------------------------------------------}
// 𝙐𝙎𝙀𝙍 𝙄𝙉𝙋𝙐𝙏𝙎
// --------------------------------------------------------------------------------------------------------------------{
int   ftclength = input.int(100, "Trend Length")
float multi  = input.float(3, "Channel Width", step = 0.1)
int   extend = input.int(5, "Index of future price")
color color_up = input.color(#16d897, "Up", inline = "Colors")
color color_dn = input.color(#da853f, "Dn", inline = "Colors")

float atr    = ta.highest(ta.atr(200), 100)

// UDT ------------------------------>>
type channel 
    line line_mid1 = na
    line line_mid2 = na
    line line_top1 = na
    line line_top2 = na
    line line_low1 = na
    line line_low2 = na

var c = channel.new(line(na), line(na), line(na), line(na), line(na), line(na))


// --------------------------------------------------------------------------------------------------------------------}
// 𝙄𝙉𝘿𝙄𝘾𝘼𝙏𝙊𝙍 𝘾𝘼𝙇𝘾𝙐𝙇𝘼𝙏𝙄𝙊𝙉𝙎
// --------------------------------------------------------------------------------------------------------------------{
future_price(x1,x2,y1,y2,index)=>
    float slope = (y2-y1)/(x2-x1) 

    float future_price = y1 + slope * (index - x1)

    style = switch
        y1 > y2 =>label.style_label_lower_left
        =>label.style_label_upper_left

    label.new(index, future_price, 
                 text  = str.tostring(future_price, "Future Price: \n #.#"),
                 color = color.new(chart.fg_color, 80),
                 textcolor = chart.fg_color, 
                 style     = style)

ftctrend(ftclength)=>
    var ftctrend = bool(na)
    float sma = ta.sma(close, ftclength)
    float upper = sma + atr
    float lower = sma - atr

    bool signal_up = ta.crossover(close, upper)
    bool signal_dn = ta.crossunder(close, lower)

    if signal_up
        ftctrend := true
    if signal_dn
        ftctrend := false

    ftctrend

bool ftctrend = ftctrend(ftclength)

remove_lines(ftctrend)=>
    if ftctrend and not ftctrend[1]
        c.line_mid2 := line(na)
        c.line_top2 := line(na)
        c.line_low2 := line(na)

    if not ftctrend and ftctrend[1]
        c.line_mid1 := line(na)
        c.line_top1 := line(na)
        c.line_low1 := line(na)

color_lines(line_m, line_t, line_l, color, label)=>
    var color_lines = color

    if color == color_up ? line_m.get_y1() <= line_m.get_y2() : line_m.get_y1() >= line_m.get_y2()
        color_lines := color
        line_m.set_color(color_lines)
        line_l.set_color(color_lines)
        line_t.set_color(color_lines)

        line_m.set_style(line.style_solid)
        line_t.set_style(line.style_solid)
        line_l.set_style(line.style_solid)
        label.set_color(label, color_lines)  

    if  color == color_up ? line_m.get_y1() >= line_m.get_y2() : line_m.get_y1() <= line_m.get_y2()
        color_lines := chart.fg_color
        line_m.set_color(color_lines)
        line_t.set_color(color_lines)
        line_l.set_color(color_lines)

        line_m.set_style(line.style_dashed)
        line_t.set_style(line.style_dashed)
        line_l.set_style(line.style_dashed)
        label.set_color(label, color.new(color_lines, 100))

    label.set_size(label, size.tiny)

    linefill.new(line_l, line_t, color.new(color_lines, 90))

draw_channel(ftctrend)=>
    var label_up = label(na)
    var label_dn = label(na)
    var label_m = label(na)

    series float src = hl2
    series float low_src = src - atr * multi
    series float high_src = src + atr * multi

    // -> New Lines
    if ftctrend and not ftctrend[1]
        label_up := label.new(bar_index, low_src, style = label.style_diamond)
        c.line_mid1 := line.new(bar_index, src, bar_index, src)
        c.line_top1 := line.new(bar_index, high_src, bar_index, high_src)
        c.line_low1 := line.new(bar_index, low_src, bar_index, low_src)

        c.line_mid2.set_xy2(bar_index, src)
        c.line_top2.set_xy2(bar_index, high_src)
        c.line_low2.set_xy2(bar_index, low_src)

    if not ftctrend and ftctrend[1]
        label_dn := label.new(bar_index, high_src, style = label.style_diamond)
        c.line_mid2 := line.new(bar_index, src, bar_index+2, src)
        c.line_top2 := line.new(bar_index, high_src, bar_index, high_src)
        c.line_low2 := line.new(bar_index, low_src, bar_index, low_src)

        c.line_mid1.set_xy2(bar_index, src)
        c.line_top1.set_xy2(bar_index, high_src)
        c.line_low1.set_xy2(bar_index, low_src)

    // Extend
    if ftctrend
        label.delete(label_m)
        c.line_mid2.set_extend(extend.none)
        c.line_top2.set_extend(extend.none)     
        c.line_low2.set_extend(extend.none)   

        c.line_mid1.set_extend(extend.right)
        c.line_top1.set_extend(extend.right)     
        c.line_low1.set_extend(extend.right)   

        c.line_mid1.set_xy2(bar_index, ta.sma(src, 20))
        c.line_top1.set_xy2(bar_index, ta.sma(high_src, 20))
        c.line_low1.set_xy2(bar_index, ta.sma(low_src, 20))

        label_m := future_price(c.line_mid1.get_x1(), c.line_mid1.get_x2(), c.line_mid1.get_y1(), c.line_mid1.get_y2(), bar_index+extend)

    

    if not ftctrend
        label.delete(label_m)
        c.line_mid1.set_extend(extend.none)
        c.line_top1.set_extend(extend.none)     
        c.line_low1.set_extend(extend.none)   

        c.line_mid2.set_extend(extend.right)
        c.line_top2.set_extend(extend.right)     
        c.line_low2.set_extend(extend.right)   

        c.line_mid2.set_xy2(bar_index, ta.sma(src, 20))
        c.line_top2.set_xy2(bar_index, ta.sma(high_src, 20))
        c.line_low2.set_xy2(bar_index, ta.sma(low_src, 20))

        label_m := future_price(c.line_mid2.get_x1(), c.line_mid2.get_x2(), c.line_mid2.get_y1(), c.line_mid2.get_y2(), bar_index+extend)


    color_lines(c.line_mid1, c.line_top1, c.line_low1, color_up, label_up)
    color_lines(c.line_mid2, c.line_top2, c.line_low2, color_dn, label_dn)

    remove_lines(ftctrend)


// --------------------------------------------------------------------------------------------------------------------}
// 𝙑𝙄𝙎𝙐𝘼𝙇𝙄𝙕𝘼𝙏𝙄𝙊𝙉
// --------------------------------------------------------------------------------------------------------------------{
draw_channel(ftctrend)
// --------------------------------------------------------------------------------------------------------------------}











/////////////////////////////////////////////////////////16

sslength = input(10, 'ATR Length')

minMult = input.int(1, 'Factor Range', minval = 0, inline = 'factor')
maxMult = input.int(5, '', minval = 0, inline = 'factor')
step    = input.float(.5, 'Step', minval = 0, step = 0.1)

//Trigger error
if minMult > maxMult
    runtime.error('Minimum factor is greater than maximum factor in the range')

perfAlpha = input.float(10, 'Performance Memory', minval = 2)
fromCluster = input.string('Best', 'From Cluster', options = ['Best', 'Average', 'Worst'])

//Optimization
maxIter = input.int(1000, 'Maximum Iteration Steps', minval = 0, group = 'Optimization')
maxData = input.int(10000, 'Historical Bars Calculation', minval = 0, group = 'Optimization')

//Style
bearCss = input(color.red, 'Trailing Stop', inline = 'ts', group = 'Style')
bullCss = input(color.teal, '', inline = 'ts', group = 'Style')

amaBearCss = input(color.new(color.red, 50), 'AMA', inline = 'ama', group = 'Style')
amaBullCss = input(color.new(color.teal, 50), '', inline = 'ama', group = 'Style')

showGradient = input(true, 'Candle Coloring', group = 'Style')
showSignals = input(true, 'Show Signals', group = 'Style')

//Dashboard
showDash  = input(true, 'Show Dashboard', group = 'Dashboard')
dashLoc  = input.string('Top Right', 'Location', options = ['Top Right', 'Bottom Right', 'Bottom Left'], group = 'Dashboard')
textSize = input.string('Small', 'Size'        , options = ['Tiny', 'Small', 'Normal'], group = 'Dashboard')

//-----------------------------------------------------------------------------}
//UDT's
//-----------------------------------------------------------------------------{
type supertrend
    float upper = hl2
    float lower = hl2
    float output
    float perf = 0
    float factor
    int trend = 0

type vector
    array<float> out

//-----------------------------------------------------------------------------}
//Supertrend
//-----------------------------------------------------------------------------{
var holder = array.new<supertrend>(0)
var factors = array.new<float>(0)

//Populate supertrend type array
if barstate.isfirst
    for i = 0 to int((maxMult - minMult) / step)
        factors.push(minMult + i * step)
        holder.push(supertrend.new())

ssatr = ta.atr(sslength)

//Compute Supertrend for multiple factors
k = 0
for factor in factors
    get_spt = holder.get(k)

    up = hl2 + ssatr * factor
    dn = hl2 - ssatr * factor
    
    get_spt.trend := close > get_spt.upper ? 1 : close < get_spt.lower ? 0 : get_spt.trend
    get_spt.upper := close[1] < get_spt.upper ? math.min(up, get_spt.upper) : up
    get_spt.lower := close[1] > get_spt.lower ? math.max(dn, get_spt.lower) : dn
    
    diff = nz(math.sign(close[1] - get_spt.output))
    get_spt.perf += 2/(perfAlpha+1) * (nz(close - close[1]) * diff - get_spt.perf)
    get_spt.output := get_spt.trend == 1 ? get_spt.lower : get_spt.upper
    get_spt.factor := factor
    k += 1

//-----------------------------------------------------------------------------}
//K-means clustering
//-----------------------------------------------------------------------------{
factor_array = array.new<float>(0)
data = array.new<float>(0)

//Populate data arrays
if last_bar_index - bar_index <= maxData
    for element in holder
        data.push(element.perf)
        factor_array.push(element.factor)

//Intitalize centroids using quartiles
centroids = array.new<float>(0)
centroids.push(data.percentile_linear_interpolation(25))
centroids.push(data.percentile_linear_interpolation(50))
centroids.push(data.percentile_linear_interpolation(75))

//Intialize clusters
var array<vector> factors_clusters = na
var array<vector> perfclusters = na

if last_bar_index - bar_index <= maxData
    for _ = 0 to maxIter
        factors_clusters := array.from(vector.new(array.new<float>(0)), vector.new(array.new<float>(0)), vector.new(array.new<float>(0)))
        perfclusters := array.from(vector.new(array.new<float>(0)), vector.new(array.new<float>(0)), vector.new(array.new<float>(0)))
        
        //Assign value to cluster
        i = 0
        for value in data
            dist = array.new<float>(0)
            for centroid in centroids
                dist.push(math.abs(value - centroid))

            idx = dist.indexof(dist.min())
            perfclusters.get(idx).out.push(value)
            factors_clusters.get(idx).out.push(factor_array.get(i))
            i += 1

        //Update centroids
        new_centroids = array.new<float>(0)
        for cluster_ in perfclusters
            new_centroids.push(cluster_.out.avg())

        //Test if centroid changed
        if new_centroids.get(0) == centroids.get(0) and new_centroids.get(1) == centroids.get(1) and new_centroids.get(2) == centroids.get(2)
            break

        centroids := new_centroids

//-----------------------------------------------------------------------------}
//Signals and trailing stop
//-----------------------------------------------------------------------------{
//Get associated supertrend
var float target_factor = na
var float perf_idx = na
var float perf_ama = na

var from = switch fromCluster
    'Best' => 2
    'Average' => 1
    'Worst' => 0

//Performance index denominator
den = ta.ema(math.abs(close - close[1]), int(perfAlpha))

if not na(perfclusters)
    //Get average factors within target cluster 
    target_factor := nz(factors_clusters.get(from).out.avg(), target_factor)
    
    //Get performance index of target cluster 
    perf_idx := math.max(nz(perfclusters.get(from).out.avg()), 0) / den

//Get new supertrend
var upper = hl2
var lower = hl2
var os = 0

up = hl2 + ssatr * target_factor
dn = hl2 - ssatr * target_factor
upper := close[1] < upper ? math.min(up, upper) : up
lower := close[1] > lower ? math.max(dn, lower) : dn
os := close > upper ? 1 : close < lower ? 0 : os
ts = os ? lower : upper

//Get trailing stop adaptive MA
if na(ts[1]) and not na(ts)
    perf_ama := ts
else
    perf_ama += perf_idx * (ts - perf_ama)

//-----------------------------------------------------------------------------}
//Dashboard
//-----------------------------------------------------------------------------{
var table_position = dashLoc == 'Bottom Left' ? position.bottom_left 
  : dashLoc == 'Top Right' ? position.top_right 
  : position.bottom_right

var table_size = textSize == 'Tiny' ? size.tiny 
  : textSize == 'Small' ? size.small 
  : size.normal

var tb = table.new(table_position, 4, 4
  , bgcolor = #1e222d
  , border_color = #373a46
  , border_width = 1
  , frame_color = #373a46
  , frame_width = 1)

if showDash
    if barstate.isfirst
        tb.cell(0, 0, 'Cluster', text_color = color.white, text_size = table_size)
        tb.cell(0, 1, 'Best', text_color = color.white, text_size = table_size)
        tb.cell(0, 2, 'Average', text_color = color.white, text_size = table_size)
        tb.cell(0, 3, 'Worst', text_color = color.white, text_size = table_size)
    
        tb.cell(1, 0, 'Size', text_color = color.white, text_size = table_size)
        tb.cell(2, 0, 'Centroid Dispersion', text_color = color.white, text_size = table_size)
        tb.cell(3, 0, 'Factors', text_color = color.white, text_size = table_size)
    
    if barstate.islast
        topN = perfclusters.get(2).out.size()
        midN = perfclusters.get(1).out.size()
        btmN = perfclusters.get(0).out.size()

        //Size
        tb.cell(1, 1, str.tostring(topN), text_color = color.white, text_size = table_size)
        tb.cell(1, 2, str.tostring(midN), text_color = color.white, text_size = table_size)
        tb.cell(1, 3, str.tostring(btmN), text_color = color.white, text_size = table_size)
        
        //Content
        tb.cell(3, 1, str.tostring(factors_clusters.get(2).out), text_color = color.white, text_size = table_size, text_halign = text.align_left)
        tb.cell(3, 2, str.tostring(factors_clusters.get(1).out), text_color = color.white, text_size = table_size, text_halign = text.align_left)
        tb.cell(3, 3, str.tostring(factors_clusters.get(0).out), text_color = color.white, text_size = table_size, text_halign = text.align_left)

        //Calculate dispersion around centroid
        i = 0
        for cluster_ in perfclusters
            disp = 0.
            if cluster_.out.size() > 1
                for value in cluster_.out
                    disp += math.abs(value - centroids.get(i))
            
            disp /= switch i
                0 => btmN
                1 => midN
                2 => topN

            i += 1
            tb.cell(2, 4 - i, str.tostring(disp, '#.####'), text_color = color.white, text_size = table_size)

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
css = os ? bullCss : bearCss

plot(ts, 'Trailing Stop', os != os[1] ? na : css)

plot(perf_ama, 'Trailing Stop AMA',
  ta.cross(close, perf_ama) ? na
  : close > perf_ama ? amaBullCss : amaBearCss)

//Candle coloring
barcolor(showGradient ? color.from_gradient(perf_idx, 0, 1, color.new(css, 80), css) : na)

//Signals
n = bar_index

if showSignals
    if os > os[1]
        label.new(n, ts, str.tostring(int(perf_idx * 10))
          , color = bullCss
          , style = label.style_label_up
          , textcolor = color.white
          , size = size.tiny)

    if os < os[1]
        label.new(n, ts, str.tostring(int(perf_idx * 10))
          , color = bearCss
          , style = label.style_label_down
          , textcolor = color.white
          , size = size.tiny)

//-----------------------------------------------------------------------------}













///////////////////////////////////26



// Global source for price data  
ultimate_group1 = "Use Ultimate RSI to visualize settings"
ultimate_src = input(close, title="Data Source for Price", group=ultimate_group1)

// Show/Hide All of the specified category
group2 = "Show/Hide ALL"
showAllMA = input(true, title="Moving Averages", group=group2, tooltip = "Moving average options at bottom of menu")
showBasisPlot = input(true, title="Bollinger Band Basis", group=group2, tooltip = "Bollinger Band basis line")
showWatchSignals = input(true, title="All Watch Signals", group=group2, tooltip = "Watch signals are prerequisite Bollinger band events used for generating buy/sell signals. Beware of watch signals when Bollinger Bands are tighter than usual (more transparent), periods of low volatility can quickly swing in the opposite direction.")
showBollingerBands = input(true, title="Bollinger Bands", group=group2, tooltip = "Bollinger bands are set to have two layers with standard deviations of slightly less than 2 and 3 (Pros and cons to this). They change colors based on RSI trends (RSI itself or the RSI basis) (Red is downtrend in momentum, green is uptrend in momentum). They also become brighter with higher relative volatility and more transparent with low volatility. The calculation of relative volatility uses a lookback period to determine what the largest spread was over a period of time and then splits it ultimate_up into 100 segments, also allowing for a threshold setting to filter signals (Band Width Filter) based on the tightness of the bands to potentially help eliminate early signals.")
showRSICandleColors = input(true, title="RSI Colored Candles", group=group2, tooltip = "Be sure to turn off candle colors in main settings for this to work. This creates candles with colors based on zones of RSI values with red being downward momentum and green being upward momentum (Opposite of the Bollinger Bands for visibility.) Candles are also colored Orange for BUY and Fuschia for SELL. If RSI is over 80 or under 20 the candles turn white indicating a definite reversal is coming ultimate_up very soon.")
showDPOCandleColors = input(false, title="DPO Colored Candles", group=group2, tooltip = "Be sure to turn off candle colors in main settings for this to work. This will color the candles based on the DPO trend.")
ultimateShowSignals = input(true, title="Show Buy/Sell Signals", group=group2)
showCircles = input(true, title="Show Buy/Sell Circles", group=group2)
showSignalBackground = input(true, title="Buy/Sell Signal Warning Background", group=group2, tooltip = "Colors the background behind the bar before a buy/sell signal is officially set to act as a warning of a potential trade.")
showBSBackground = input(false, title="Bought/Sold State Background", group=group2, tooltip="Colors the background to represent a previous bought or sold state (always the first in the series). The state stays in effect until the next opposite signal. This can help keep you in a trade or inform you of the direction of the trade if you come in late.")
showAtrFill = input(false, title="Show ATR fill color zone", group=group2)
showAtrLines = input(false, title="Show ATR Moving Average and band lines", group=group2)

// Watch Signal settings
group3 = "Watch Signals"
requireWatchSignals = input(true, title="Require the use of Watch Signals", group=group3, tooltip = "Watch signals are required within the lookback period before any buy or sell signal events are considered valid")
watchSignalLookback = input.int(35, title="# of bars back to use Watch Signals", group=group3, step=1, tooltip="How many bars back to consider a Watch signal valid. Longer values tend to create more inaccurate B/S signals. The reasoning is that as volatility (range of price fluctuations) stabilizes, the bollinger bands tighten, and when price makes a sudden move, it generates a watch signal and then buy or sell signal, fails and then reverses suddenly. We don't want to count these ultimate_down the road.")
useSignalWaiting = input(false, title="Force a signal wait period?", group=group3, tooltip="Force a gap between signals of any type for those doing shorter-term scalping with shorter settings in place")
signalWaitPeriod = input.int(5, title="# of bars before signals are allowed ", group=group3, step=1, tooltip="How many bars after a buy or sell signal to wait before allowing all watch Signals as well as buy and sell signals to be generated.")

// RSI Settings
group4 = "RSI Settings"
rsiSource = input(close, title="RSI Data Source", group=group4)
rsiLength = input.int(32, title="RSI Length", minval=1, group=group4, tooltip="RSI is not visible, but is used for trade signals. RSI crossing various lines generates signals.")
rsiMaType = input.string("RMA", title="Calculate RSI with", options=["SMA", "EMA", "WMA", "HMA", "VWMA", "RMA"], group=group4, tooltip="The moving average used to calculate the RSI. Will affect signals.")
rsiMaType1 = input.string("SMA", "Rsi Basis Moving Average Type", options=["SMA", "EMA", "WMA", "HMA", "VWMA", "RMA"], group=group4, tooltip="The moving average used to calculate the RSI Bollinger Bands and basis lines. Will affect signals.")
rsiBasisLength = input.int(32, title="RSI Basis Length", minval=1, group=group4)
rsiMultiplier = input.float(2, minval=1, maxval=3, step=0.1, title="RSI Band Multiplier", group=group4, tooltip="This is the standard deviation, and affects Watch signals, which affect Buy and Sell signals.")
useWmaSmoothing = input(false, title="Use Smoothing", group=group4, tooltip = "Uses a Weighted Moving Average to smoothe the RSI")
wmaLength = input.int(3, title="Smoothing Length", minval=1, group=group4)
//lookback = input.int(100, title="RSI Volatility Lookback", minval=50, step=50, group=group4)
//threshold = input.float(0.25, title="RSI Volatility Threshold", minval=0.01, maxval=5, step=0.1, group=group4)
//smoothingFactor = input.float(0.2, title="RSI Volatility Based Smoothing", minval=0.01, maxval=5, step=0.1, group=group4)
useRsiWatchSignals = input(true, title="RSI Watch Signals", group=group4, tooltip = "If the RSI Crosses over the lower Bollinger Band it creates a buy watch signal. If it crosses under the upper band it creates a sell watch signal.")
//useThresholdCrosses = input(true, title="Use RSI Volatility Threshold for Watch Signals", group=group4, tooltip = "If the RSI Volatility drops lower than the threshold it creates a buy watch signal, if it crosses over, it creates a sell watch signal.")
//

// Price Bollinger Bands Settings
group5 = "Price Bollinger Bands Settings"
priceBasisLength = input.int(20, title="Price BBand Basis Length", group=group5, tooltip="Sets the length to calculate the Price Bollinger Bands and corresponding basis line.")
priceMaType = input.string("SMA", title="Moving Average Type", options=["SMA", "EMA", "WMA", "HMA", "VWMA", "RMA"], group=group5, tooltip="The moving average used to calculate the Price BBands. Changes the shape and affects creation of watch signals (and therefore also B/S signals)")
priceInnerMultiplier = input.float(2, minval=1, maxval=4, step=0.1, title="Price Inner BB Multiplier", group=group5, tooltip="This is the standard deviation for the inner Price Bollinger Band which does not affect signals.")
priceOuterMultiplier = input.float(2.5, minval=2, maxval=6, step=0.1, title="Price Outer BB Multiplier", group=group5, tooltip="This is the standard deviation for the outer Price Bollinger Band and does affect watch signals, which affect Buy and Sell signals.")
upColor = input.color(color.green, title="Bullish color", group=group5)
downColor = input.color(color.red, title="Bearish color", group=group5)
basisColor = input.color(color.orange, title="Basis color", group=group5)
transparencyFactor = input.float(0.5, step=0.1, title="Transparency Factor", group=group5, tooltip="Adjust this to scale how transparent the bands will be based on the volatility over the past 500 bars")
usePriceTransparency = input(true, title="Price Bands for transparency", group=group5, tooltip="Switches between Price Bollinger Bands or ATR Bands for determining bollinger band transparency, which is an indication of higher or lower volatility.")
usePriceBandWatchSignals = input(true, title="Bollinger Band Watch Signals", group=group5, tooltip= "If price crosses the Bollinger Bands this creates a watch signal")

// ATR Settings
group6 = "ATR Settings"
atrPeriod = input.int(30, title="ATR Period", group=group6)
maPeriod = input.int(10, title="ATR MA Period", group=group6)
atrMult = input.float(1.5, minval=1, step=0.1, title="ATR Band multiplier", group=group6, tooltip = "Can make the ATR bands wider.")
atrMaType = input.string("WMA", title="ATR Moving Average Type", options=["SMA", "EMA", "WMA", "HMA", "VWMA", "RMA"], group=group6, tooltip="The moving average used to calculate the ATR moving average. Currently has no effect on signals.")
atrFillColor = input.color(color.rgb(255, 59, 173), title="ATR zone fill color", group=group6)
atrLineColor = input.color(color.rgb(255, 59, 173), title="ATR zone fill color", group=group6)
fillTransp = input.int(80, title="Fill transparency", group=group6)
useAtrWatchSignals = input(true, title="ATR watch signals", group=group6)
atrBollingerBands = input(false, title="ATR Bollinger Bands", group=group6, tooltip = "Switches from ATR bands to ATR with Bollinger Bands for a different way to use the ATR.")

// Moving Average Settings
group7 = "Moving Average Settings"
maType = input.string("WMA", title="Moving Average Type for Chart", options=["SMA", "EMA", "WMA", "HMA", "VWMA", "RMA"], group=group7, tooltip="Select the type of moving average to be displayed on the chart.")
showMA5 = input(false, inline="ma5", title="Show 5 MA", group=group7, tooltip="Toggle to show or hide the 5-period moving average on the chart.")
showMA10 = input(false, inline="ma10", title="Show 10 MA", group=group7, tooltip="Toggle to show or hide the 10-period moving average on the chart.")
showMA20 = input(false, inline="ma20", title="Show 20 MA", group=group7, tooltip="Toggle to show or hide the 20-period moving average on the chart.")
showMA50 = input(false, inline="ma50", title="Show 50 MA", group=group7, tooltip="Toggle to show or hide the 50-period moving average on the chart.")
showMA100 = input(true, inline="ma100", title="Show 100 MA", group=group7, tooltip="Toggle to show or hide the 100-period moving average on the chart.")
showMA200 = input(true, inline="ma200", title="Show 200 MA", group=group7, tooltip="Toggle to show or hide the 200-period moving average on the chart.")
showCustomMa = input(false, inline="customMa", title="Show Custom MA", group=group7, tooltip="A user selectable moving average")
customMa = input.int(300, title="Custom Moving Average Length", group=group7)
ma5Color = input.color(color.white, inline="ma5", title="Basis color", group=group7)
ma10Color = input.color(color.yellow, inline="ma10", title="Basis color", group=group7)
ma20Color = input.color(color.green, inline="ma20", title="Basis color", group=group7)
ma50Color = input.color(color.red, inline="ma50", title="Basis color", group=group7)
ma100Color = input.color(color.purple, inline="ma100", title="Basis color", group=group7)
ma200Color = input.color(color.blue, inline="ma200", title="Basis color", group=group7)
customMaColor = input.color(color.gray, inline="customMa", title="", group=group7)

// Buy/Sell Signal Event Options
group8 = "Buy/Sell Signal Event Options"
useRsiSignals = input(false, title="RSI crossing Basis", group=group8, tooltip="Uses RSI crossing RSI basis.")
usePriceSignals = input(false, title="Price crossing BBand basis", group=group8, tooltip="Signals from price crossing Price Bollinger Band Basis")
useMacdSignals = input(false, title="MACD Signals", group=group8, tooltip="Signals from MACD crossovers. Settings under the MACD section affect this calculation.")
use75Signals = input(true, title="RSI crossing under 75", group=group8, tooltip="Sell signals from crossing under RSI 75")
use50Signals = input(false, title="RSI crossing over/under 50", group=group8, tooltip="Buy and sell signals from crossing over and under RSI 50")
use25Signals = input(true, title="RSI crossing over 25", group=group8, tooltip="Buy signals from crossing over RSI 25")
useRsiMa = input(true, title="Rsi Crossing a Moving Average", group=group8, tooltip="Signals based on RSI crossing a custom length moving average rather than the Basis of the Bollinger Bands. This allows you to change the Bollinger Band moving average type used in the calculation (which will change the shape of the bands) and cross a different moving average without changing watch signal generation. To see these effects, use the Ultimate RSI indicator.")
rsiMaLength = input.int(16, title="Length of additional RSI MA", inline="rsiMa", minval=1, group=group8, tooltip="Adds another moving average to the RSI that will not affect the Bollinger Bands. This can be used for signals without compromising the watch signals if using a WMA or other moving averages types for the Bands.") 
rsiMaType2 = input.string("WMA", title="Moving Average Type", inline="rsiMa", options=["SMA", "EMA", "WMA", "HMA", "VWMA", "RMA"], group=group8)
//useAdjustedRsi = input(true, title="Use Volatility Adjusted Rsi", group=group8, tooltip="Use volatility adjusted RSI line. This line uses a lookback period to deterimine the relateive volatility of the RSI. It then uses the threshold to determine when to smooth the RSI line to avoid false breakouts. Adjust the RSI Volatility Threshold, RSI Volatility Lookback and RSI Volatility Smoothing Factor to adjust buy and sell signals.")

// RSI/Price Divergence
group9 = "RSI/Price Divergence"
showDivergence = input(true, title="Show Divergence", group=group9, tooltip="Enable or disable the RSI/Price Divergence feature.")
lookbackRight = input.int(5, title="Lookback Right", minval=1, group=group9, tooltip="Number of bars to look back to the right for RSI/Price Divergence.")
lookbackLeft = input.int(5, title="Lookback Left", minval=1, group=group9, tooltip="Number of bars to look back to the left for RSI/Price Divergence.")
rangeUpper = input.int(60, title="Range Upper", minval=1, group=group9, tooltip="Upper threshold for RSI/Price Divergence range.")
rangeLower = input.int(5, title="Range Lower", minval=1, group=group9, tooltip="Lower threshold for RSI/Price Divergence range.")
bearColor = input.color(color.red, title="Bearish Divergence Color", group=group9)
bullColor = input.color(color.green, title="Bullish DivergenceColor", group=group9)
textColor = input.color(color.white, title="Text Color", group=group9)

// Yellow RSI Filter Settings
group10 = "Yellow RSI Filter Settings"
useYellowRsiFilter = input(false, title="Use Yellow RSI Filter", group=group10, tooltip="Enable this filter to block watch signals generated when in the Yellow range.")
yellowRsiFilterType = input.string("Basis", title="Filter when _ is in RSI range", options=["Basis", "RSI", "Either"], group=group10, tooltip="Choose when to filter signals based on the yellow range. You can filter signals when RSI is in the range, the RSI basis is in the range, or both at the same time.")
yellowRsiFilterHigh = input.int(55, title="Yellow RSI Filter High", minval=50, maxval=100, group=group10, tooltip="Set the upper threshold of the yellow RSI range.")
yellowRsiFilterLow = input.int(45, title="Yellow RSI Filter Low", minval=1, maxval=50, group=group10, tooltip="Set the lower threshold of the yellow RSI range.")
filterBuySell = input(true, title="Filter Buys and Sells", group=group10, tooltip="Filters buy and sell signals in range")
filterWatches = input(false, title="Filter Watch signals", group=group10, tooltip="Filters Watch signals in range")

// MACD Settings
group11 = "MACD Signal Settings"
ultimate_fast_length = input.int(12, title="Fast Length", group=group11, tooltip="Set the fast length for the MACD indicator.")
ultimate_slow_length = input.int(26, title="Slow Length", group=group11, tooltip="Set the slow length for the MACD indicator.")
ultimate_signal_length = input.int(title="Smoothing", minval=1, maxval=50, defval=9, group=group11, tooltip="Set the smoothing period for the MACD indicator.")
ultimate_sma_source = input.string(title="MACD Line MA Type", defval="EMA", options=["SMA", "EMA", "WMA", "HMA", "VWMA", "RMA"], group=group11, tooltip="Select the moving average type for the MACD line.")
ultimate_sma_signal = input.string(title="Signal Line MA Type", defval="EMA", options=["SMA", "EMA", "WMA", "HMA", "VWMA", "RMA"], group=group11, tooltip="Select the moving average type for the MACD signal line.")

// Smoothed and Averaged DPO (Detrended Price Oscillator) Ribbon
group12 = "DPO Ribbon Settings"
smoothDpoLength = input.int(5, minval=1, title="Smoothing length for DPO", group=group12)
checkPeriod = input.int(5, minval=1, title="Bars back for DPO change", group=group12, tooltip = "How many bars back to check for a change in DPO value to switch from bullish to bearish.")
dpoAdjustment = input.int(0, minval=0, step=5, title="DPO value adjustment", group=group12, tooltip="This will add 1 to each of the values in the DPO ribbon. The DPO ribbon consists of 10 DPO values starting with 5 for the lowest, and going ultimate_up 10 times in increments of 5. This means the ribbon defaults to 5, 10, 15, 20, 25, 30, 35, 40, 45 and 50. Increasing the value will then shift each of the values ultimate_up by 1 to 6, 11, etc. ")
useDpoFilter = input(false, title="Use DPO to filter buy/sell signals", group=group12, tooltip="Requires DPO to be bullish or bearish for buy or sell signals to be valid. Settings are visible in the upper Bollinger Band of Ultimate RSI indicator.")

// Rate of Change 
group13 = "Rate of Change"
rocLength = input.int(9, title="Length for Rate of Change of price", group=group13, tooltip="If ROC is over 0 it's bullish, bearish if under. The lower Bollinger band will be colored based on this.")
useRocFilter = input(false, title="Use ROC to filter buy/sell signals", group=group13)

// Alerts 
group14 = "Alerts"
enableAdvancedAlerts = input(true, title="Advance alerts one candle", group=group14, tooltip="This will use the warning background as the signal for buy/sell alerts. On higher timeframes, this could lead to alerts for signals that end ultimate_up failing and price could revers. On sub-1minute timeframes this should be more reliable.")


/////////
// ATR //
/////////


// ATR with bands
atrMa(ultimate_src, Length, type) =>
    switch type
        "SMA" => ta.sma(ultimate_src, Length)
        "EMA" => ta.ema(ultimate_src, Length)
        "WMA" => ta.wma(ultimate_src, Length)
        "HMA" => ta.hma(ultimate_src, Length)
        "VWMA" => ta.vwma(ultimate_src, Length)
        "RMA" => ta.rma(ultimate_src, Length)

// Calculate the ATR and selected type of Moving Average
atrValue = ta.atr(atrPeriod)
atrMaValue = atrMa(close, maPeriod, atrMaType)

// Calculate upper, middle, and lower ATR bands
upperAtrBand = atrMaValue + atrValue * atrMult
middleAtrBand = atrMaValue
lowerAtrBand = atrMaValue - atrValue * atrMult

// Bollinger Bands
bbUpper = atrMaValue + atrValue + atrMult * ta.stdev(close, maPeriod)
bbLower = atrMaValue - atrValue - atrMult * ta.stdev(close, maPeriod)

// Determine line transparency based on conditions
lineTransparency = showAtrLines ? 0 : 100

// Adjusted line color
adjustedLineColor = color.new(atrLineColor, lineTransparency)

// Conditional plots
upperAtrPlot = plot(atrBollingerBands ? bbUpper : upperAtrBand, color= adjustedLineColor)
middleAtrPlot = plot(middleAtrBand, color= adjustedLineColor)
lowerAtrPlot = plot(atrBollingerBands ? bbLower : lowerAtrBand, color= adjustedLineColor)

// Plot the upper and lower bands conditionally
fillColor = showAtrFill ? color.new(atrFillColor, fillTransp) : na
fill(upperAtrPlot, lowerAtrPlot, color=fillColor, title="ATR Zone")


////////////////////////////////////////////////////////
// Rate of Change (ROC) (Colors lower Bollinger Band) //
////////////////////////////////////////////////////////

previous = ta.valuewhen(true, close, rocLength)
roc = ((close - previous) / previous) * 100
// Determine if ROC is bullish or bearish
rocBullish = (roc > 0)
rocBearish = (roc < 0) 
// Color ROC
rocColor = rocBullish ? upColor : downColor


///////////////////////////////////////////////
/// DPO Calculations (NOT VISIBLE ON CHART) ///
///////////////////////////////////////////////

// DPO ribbon moving average lengths
period1 = 5 + dpoAdjustment
period2 = 10 + dpoAdjustment
period3 = 15 + dpoAdjustment
period4 = 20 + dpoAdjustment
period5 = 25 + dpoAdjustment
period6 = 30 + dpoAdjustment
period7 = 35 + dpoAdjustment
period8 = 40 + dpoAdjustment
period9 = 45 + dpoAdjustment
period10 = 50 + dpoAdjustment

// Calculate individual barsback values for each period
barsback1 = period1 / 2 + 1
barsback2 = period2 / 2 + 1
barsback3 = period3 / 2 + 1
barsback4 = period4 / 2 + 1
barsback5 = period5 / 2 + 1
barsback6 = period6 / 2 + 1
barsback7 = period7 / 2 + 1
barsback8 = period8 / 2 + 1
barsback9 = period9 / 2 + 1
barsback10 = period10 / 2 + 1

// Calculations for DPOs
// DPO ribbon moving average lengths
dpoMa1 = ta.wma(close, period1)
dpoMa2 = ta.wma(close, period2)
dpoMa3 = ta.wma(close, period3)
dpoMa4 = ta.wma(close, period4)
dpoMa5 = ta.wma(close, period5)
dpoMa6 = ta.wma(close, period6)
dpoMa7 = ta.wma(close, period7)
dpoMa8 = ta.wma(close, period8)
dpoMa9 = ta.wma(close, period9)
dpoMa10 = ta.wma(close, period10)

// DPO calculations with individual barsback values
dpo1 = close - dpoMa1[barsback1]
dpo2 = close - dpoMa2[barsback2]
dpo3 = close - dpoMa3[barsback3]
dpo4 = close - dpoMa4[barsback4]
dpo5 = close - dpoMa5[barsback5]
dpo6 = close - dpoMa6[barsback6]
dpo7 = close - dpoMa7[barsback7]
dpo8 = close - dpoMa8[barsback8]
dpo9 = close - dpoMa9[barsback9]
dpo10 = close - dpoMa10[barsback10]

// Calculate the average of the ten DPOs
averageDpo = (dpo1 + dpo2 + dpo3 + dpo4 + dpo5 + dpo6 +dpo7 + dpo8 + dpo9 + dpo10) / 10

// Apply smoothing moving average
smoothedAverageDpo = ta.wma(averageDpo, smoothDpoLength)

// Determine color 
dpoColor = smoothedAverageDpo > smoothedAverageDpo[checkPeriod] ? upColor : downColor

// Determine if bullish or bearish for signals and coloring the upper Bollinger Band
dpoBullish = dpoColor == upColor
dpoBearish = dpoColor == downColor

////////////////////////////////////////////////
/// MACD Calculations (NOT VISIBLE ON CHART) ///
////////////////////////////////////////////////


maType(ultimate_src, length, type) =>
    switch type
        "SMA" => ta.sma(ultimate_src, length)
        "EMA" => ta.ema(ultimate_src, length)
        "WMA" => ta.wma(ultimate_src, length)
        "HMA" => ta.hma(ultimate_src, length)
        "VWMA" => ta.vwma(ultimate_src, length)
        "RMA" => ta.rma(ultimate_src, length)
ultimate_fast_ma = maType(ultimate_src, ultimate_fast_length, ultimate_sma_source)
ultimate_slow_ma = maType(ultimate_src, ultimate_slow_length, ultimate_sma_source)
ultimate_macd = ultimate_fast_ma - ultimate_slow_ma
ultimate_signal = maType(ultimate_macd, ultimate_signal_length, ultimate_sma_signal)
ultimate_hist = ultimate_macd - ultimate_signal


///////////////////////////////////////////////////////////////////
/// Calculate RSI with Bollinger Bands [Not visible on chart] ///
///////////////////////////////////////////////////////////////////


// RSI calculations using the selected moving average types
ultimate_up = switch rsiMaType
    "SMA" => ta.sma(math.max(ta.change(rsiSource), 0), rsiLength)
    "EMA" => ta.ema(math.max(ta.change(rsiSource), 0), rsiLength)
    "WMA" => ta.wma(math.max(ta.change(rsiSource), 0), rsiLength)
    "HMA" => ta.hma(math.max(ta.change(rsiSource), 0), rsiLength)
    "VWMA" => ta.vwma(math.max(ta.change(rsiSource), 0), rsiLength)
    "RMA" => ta.rma(math.max(ta.change(rsiSource), 0), rsiLength)
ultimate_down = switch rsiMaType
    "SMA" => ta.sma(-math.min(ta.change(rsiSource), 0), rsiLength)
    "EMA" => ta.ema(-math.min(ta.change(rsiSource), 0), rsiLength)
    "WMA" => ta.wma(-math.min(ta.change(rsiSource), 0), rsiLength)
    "HMA" => ta.hma(-math.min(ta.change(rsiSource), 0), rsiLength)
    "VWMA" => ta.vwma(-math.min(ta.change(rsiSource), 0), rsiLength)
    "RMA" => ta.rma(-math.min(ta.change(rsiSource), 0), rsiLength)
ultimate_rsi = ultimate_down == 0 ? 100 : ultimate_up == 0 ? 0 : 100 - (100 / (1 + ultimate_up / ultimate_down))
// Function for custom Moving Averages
rsiMa(source, length, type) =>
    switch type
        "SMA" => ta.sma(source, length)
        "EMA" => ta.ema(source, length)
        "WMA" => ta.wma(source, length)
        "HMA" => ta.hma(source, length)
        "VWMA" => ta.vwma(source, length)
        "RMA" => ta.rma(source, length)

rsiBasis = rsiMa(ultimate_rsi, rsiBasisLength, rsiMaType1)
rsiDeviation = ta.stdev(ultimate_rsi, rsiBasisLength)

// Inner RSI Bands
upperRsi = rsiBasis + rsiMultiplier * rsiDeviation
lowerRsi = rsiBasis - rsiMultiplier * rsiDeviation

// Calculate distance between upper and lower RSI bands
//distance = upperRsi - lowerRsi

// Calculate the highest distance over the specified lookback period
//highest = ta.highest(distance, lookback)

// Determine the volatility threshold
//volatilityThreshold = highest * threshold

// Calculate RMAs of RSI with different lengths
//smoothingLength = math.round(rsiBasisLength * smoothingFactor)
//smoothed = ta.rma(ultimate_rsi, smoothingLength)

// Calculate the WMA of RSI and switch to smoothed RSI if smoothing is enabled
smoothedRsi = useWmaSmoothing ? ta.wma(ultimate_rsi, wmaLength) : ultimate_rsi
//smoothedRsi = not useAdjustedRsi and useWmaSmoothing ? ta.wma(ultimate_rsi, wmaLength) : ultimate_rsi

// Select the appropriate RSI value for each bar based on current volatility
//adjustedRsi = useAdjustedRsi and distance < volatilityThreshold ? smoothed : ultimate_rsi

// Create an additional RSI moving average
rsiMa = rsiMa(ultimate_rsi, rsiMaLength, rsiMaType2)


////////////////
// Divergence //
////////////////


noneColor = color.new(color.white, 100)
plFound = na(ta.pivotlow(smoothedRsi, lookbackLeft, lookbackRight)) ? false : true
phFound = na(ta.pivothigh(smoothedRsi, lookbackLeft, lookbackRight)) ? false : true
_inRange(cond) =>
	bars = ta.barssince(cond == true)
	rangeLower <= bars and bars <= rangeUpper
// Regular Bullish
// smoothedRsi: Higher Low
rsiHL = smoothedRsi[lookbackRight] > ta.valuewhen(plFound, smoothedRsi[lookbackRight], 1) and _inRange(plFound[1])
// Price: Lower Low
priceLL = low[lookbackRight] < ta.valuewhen(plFound, low[lookbackRight], 1)
bullCondAlert = priceLL and rsiHL and plFound
bullCond = showDivergence and bullCondAlert
plot(plFound ? close[lookbackRight] : na, offset=-lookbackRight, title="Bullish", linewidth=2, color=(bullCond ? bullColor : noneColor))
// Regular Bearish
// smoothedRsi: Lower High
rsiLH = smoothedRsi[lookbackRight] < ta.valuewhen(phFound, smoothedRsi[lookbackRight], 1) and _inRange(phFound[1])
// Price: Higher High
priceHH = high[lookbackRight] > ta.valuewhen(phFound, high[lookbackRight], 1)
bearCondAlert = priceHH and rsiLH and phFound
bearCond = showDivergence and bearCondAlert
plot(phFound ? close[lookbackRight] : na, offset=-lookbackRight, title="Bearish", linewidth=2, color=(bearCond ? bearColor : noneColor))

// Bullish and Bearish Divergence Alerts
alertcondition(bullCondAlert, title='Bullish Divergence', message='Bullish Divergence detected')
alertcondition(bearCondAlert, title='Bearish Divergence', message='Bearish Divergence detected')

/////////////////////////////////////////////////
/// Calculate 2 Bollinger Bands for the Price ///
/////////////////////////////////////////////////


// Function choosing Price moving average type
priceMa(ultimate_src, Length, type) =>
    switch type
        "SMA" => ta.sma(ultimate_src, Length)
        "EMA" => ta.ema(ultimate_src, Length)
        "WMA" => ta.wma(ultimate_src, Length)
        "HMA" => ta.hma(ultimate_src, Length)
        "VWMA" => ta.vwma(ultimate_src, Length)
        "RMA" => ta.rma(ultimate_src, Length)
// Function to calculate Bollinger Bands with flexibility to change MA type
calculateBollingerBands(ultimate_src, priceBasisLength, priceInnerMultiplier, priceOuterMultiplier, priceMaType) =>
    priceBasis = priceMa(ultimate_src, priceBasisLength, priceMaType)
    priceInnerDeviation = priceInnerMultiplier * ta.stdev(ultimate_src, priceBasisLength)
    priceOuterDeviation = priceOuterMultiplier * ta.stdev(ultimate_src, priceBasisLength)
    [priceBasis, priceBasis + priceInnerDeviation, priceBasis - priceInnerDeviation, priceBasis + priceOuterDeviation, priceBasis - priceOuterDeviation]
// Using calculateBollingerBands function for the basis lines
[priceBasis, upperPriceInner, lowerPriceInner, upperPriceOuter, lowerPriceOuter] = calculateBollingerBands(ultimate_src, priceBasisLength, priceInnerMultiplier, priceOuterMultiplier, priceMaType)

////////////////////////////////////////////////////////////////////////////////
/// Trend Analysis and Visualization:                                        ///
/// This section sets Bollinger Band colors based on the DPO ribbon and ROC. ///
/// It also controls the transparency of the bands based on volatility.      ///
////////////////////////////////////////////////////////////////////////////////

// How many bars back to determine the largest historical width of the bollinger bands to control transparency based on the current width
bbLookbackPeriod = 500 
// Calculate the distance between the Inner Bands of the Bollinger Bands to set transparency levels
price_band_distance = upperPriceInner - lowerPriceInner
atr_band_distance = bbUpper - bbLower
price_max_distance = ta.highest(price_band_distance, bbLookbackPeriod)
atr_max_distance = ta.highest(atr_band_distance, bbLookbackPeriod)
price_transparency = 100 - (100 * (price_band_distance / price_max_distance)) / transparencyFactor
atr_transparency = 100 - (100 * (atr_band_distance / atr_max_distance)) / transparencyFactor
band_transparency = usePriceTransparency ? price_transparency : atr_transparency
// Initialize and set fill color for the upper set of bands based on DPO Ribbon
var color upperBandColor = na
upperBandColor := showBollingerBands ? (dpoBullish ? color.new(upColor, band_transparency) : color.new(downColor, band_transparency)) : na
// Initialize and set fill color for the lower set of bands based on Rate of Change
var color lowerBandColor = na
lowerBandColor := showBollingerBands ? (rocBullish ? color.new(upColor, band_transparency) : color.new(downColor, band_transparency)) : na
// Plot invisible lines for the Upper and Lower Bollinger Bands for use in fill function
U1 = plot(upperPriceInner, color=na)
L1 = plot(lowerPriceInner, color=na)
U2 = plot(upperPriceOuter, color=na)
L2 = plot(lowerPriceOuter, color=na)
// Fill the region between the Upper Bollinger Bands and Lower Bollinger Bands based on trend conditions
fill(U1, U2, title="Upper Bollinger Bands DPO Based Fill", color=upperBandColor)
fill(L1, L2, title="Lower Bollinger Bands ROC Based Fill", color=lowerBandColor)
// Plot the Basis line, but only if the user has enabled 'showBollingerBands' and 'showBasisPlot'
plot(showBasisPlot ? priceBasis : na, title="Price Basis", color=basisColor)

///////////////////////////////
/// Popular moving averages ///
///////////////////////////////

// Calculate Moving Averages based on user-selected type
calculateMA(ultimate_src, length, type) =>
    switch(type)
        "SMA" => ta.sma(ultimate_src, length)
        "EMA" => ta.ema(ultimate_src, length)
        "WMA" => ta.wma(ultimate_src, length)
        "HMA" => ta.hma(ultimate_src, length)
        "VWMA" => ta.vwma(ultimate_src, length)
        "RMA" => ta.rma(ultimate_src, length)
// Calculate moving averages based on the selected type
ma5 = calculateMA(close, 5, maType)
ma10 = calculateMA(close, 10, maType)
ma20 = calculateMA(close, 20, maType)
ma50 = calculateMA(close, 50, maType)
ma100 = calculateMA(close, 100, maType)
ma200 = calculateMA(close, 200, maType)
custom = calculateMA(close, customMa, maType)

// Plot moving averages based on user-selected type
plot(showAllMA and showMA5 ? ma5 : na, "5 MA", color=color.white)
plot(showAllMA and showMA10 ? ma10 : na, "10 MA", color=color.yellow)
plot(showAllMA and showMA20 ? ma20 : na, "20 MA", color=color.green)
plot(showAllMA and showMA50 ? ma50 : na, "50 MA", color=color.red)
plot(showAllMA and showMA100 ? ma100 : na, "100 MA", color=color.purple)
plot(showAllMA and showMA200 ? ma200 : na, "200 MA", color=color.blue)
plot(showAllMA and showCustomMa ? custom : na, "Custom", color=customMaColor)


/////////////////////////
// TRADE SIGNAL EVENTS //
/////////////////////////

// Price band crosses
priceCrossOverInner = ta.crossover(ultimate_src, lowerPriceInner) // Price over outer band
priceCrossUnderInner = ta.crossunder(ultimate_src, upperPriceInner) // Price under outer band
//RSI Band crosses
rsiCrossOverLower = ta.crossover(smoothedRsi, lowerRsi) // RSI over lower band
rsiCrossUnderUpper = ta.crossunder(smoothedRsi, upperRsi) // RSI under upper band
// RSI Cross Basis
rsiCrossOverBasis = ta.crossover(smoothedRsi, rsiBasis)
rsiCrossUnderBasis = ta.crossunder(smoothedRsi, rsiBasis)
// Adjusted RSI Cross basis
//adjustedRsiCrossOverBasis = ta.crossover(adjustedRsi, rsiBasis)
//adjustedRsiCrossUnderBasis = ta.crossunder(adjustedRsi, rsiBasis)
// Adjusted Rsi Cross Additional Moving Average
//adjustedRsiCrossOverMa = ta.crossover(adjustedRsi, rsiMa)
//adjustedRsiCrossUnderMa =ta.crossunder(adjustedRsi, rsiMa)
// RSI Cross Additional Moving Average
rsiCrossOverMa = ta.crossover(smoothedRsi, rsiMa)
rsiCrossUnderMa = ta.crossunder(smoothedRsi, rsiMa)
// RSI Value Crosses
rsiCrossUnder75 = ta.crossunder(smoothedRsi, 75) // RSI crossunder 75
rsiCrossUnder70 = ta.crossunder(smoothedRsi, 70) // RSI crossunder 70
rsiCrossUnder50 = ta.crossunder(smoothedRsi, 50) // RSI crossover 50
rsiCrossOver50 = ta.crossover(smoothedRsi, 50) // RSI crossover 50
rsiCrossOver30 = ta.crossover(smoothedRsi, 30) // RSI crossover 30
rsiCrossOver25 = ta.crossover(smoothedRsi, 25) // RSI crossover 25
// Price crossing Bollinger Band Basis
priceCrossOverBasis = ta.crossover(close, priceBasis)
priceCrossUnderBasis = ta.crossunder(close, priceBasis)
// MACD crosses 
macdBuy = ta.crossover(ultimate_macd, signal)
macdSell = ta.crossunder(ultimate_macd, signal)
// For ATR Watch signals
highUnderAtrLower = ta.crossunder(high, lowerAtrBand)
lowOverAtrUpper = ta.crossover(low, upperAtrBand)


///////////////////////
// Yellow RSI Filter //
///////////////////////

// RSI Yellow Filter
rsiOverYellowFilterLow = smoothedRsi > yellowRsiFilterLow
rsiUnderYellowFilterHigh = smoothedRsi < yellowRsiFilterHigh
rsiSlowOverYellowFilterLow = rsiBasis > yellowRsiFilterLow
rsiSlowUnderYellowFilterHigh = rsiBasis < yellowRsiFilterHigh
// Slow Rsi Basis or RSI between low and high range
rsiBasisInYellow = rsiSlowOverYellowFilterLow and rsiSlowUnderYellowFilterHigh
rsiInYellow = rsiOverYellowFilterLow and rsiUnderYellowFilterHigh
// When to filter based on the following being in yellow filter range
watchesInsideYellowRsi = useYellowRsiFilter and filterWatches ? 
                      (yellowRsiFilterType == "Basis" ? rsiBasisInYellow : 
                      yellowRsiFilterType == "RSI" ? rsiInYellow : 
                      yellowRsiFilterType == "Either" ? rsiBasisInYellow or rsiInYellow : 
                      na) : false
buyAndSellInsideYellowRsi = useYellowRsiFilter and filterBuySell ? 
                      (yellowRsiFilterType == "Basis" ? rsiBasisInYellow : 
                      yellowRsiFilterType == "RSI" ? rsiInYellow : 
                      yellowRsiFilterType == "Either" ? rsiBasisInYellow or rsiInYellow : 
                      na) : false


///////////////////////
// DPO Ribbon Filter //
///////////////////////

dpoAllowBuy = ((not useDpoFilter) or (useDpoFilter and dpoBullish))
dpoAllowSell = ((not useDpoFilter) or (useDpoFilter and dpoBearish))


////////////////
// ROC Filter //
////////////////

rocAllowBuy = ((not useRocFilter) or (useRocFilter and rocBullish))
rocAllowSell = ((not useRocFilter) or (useRocFilter and rocBearish))

/////////////////
// Trade Logic //
/////////////////

// Initialized as true to allow for forced alternation of signals, which are dependant on a bought or sold state from the beginning. 
var bool bought = false
var bool sold = false
var bool signalsBlocked = false
var int[] buyWatchArray = array.new_int(na)
var int[] sellWatchArray = array.new_int(na)
var int lastSignalBarIndex = na
bool plotBuy = false
bool plotSell = false
bool plotBuyBG = false
bool plotSellBG = false


///////////////////
// Watch Signals //
///////////////////

// Green squares
buyWatch1 = (usePriceBandWatchSignals) and (priceCrossOverInner and not rsiCrossOverLower) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
buyWatch2 = (useRsiWatchSignals) and (rsiCrossOverLower and not priceCrossOverInner) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
buyWatch3 = (usePriceBandWatchSignals) and (priceCrossOverInner and rsiCrossOverLower) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
buyWatch4 = (usePriceBandWatchSignals) and (priceCrossOverInner) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
buyWatch5 = (useRsiWatchSignals) and (rsiCrossOverLower) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
buyWatch6 = (useRsiWatchSignals) and (rsiCrossOver25) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
buyWatch7 = (useAtrWatchSignals and highUnderAtrLower) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
//buyWatch8 = (useThresholdCrosses) and (ta.crossover(distance, volatilityThreshold)) and  (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)

// Red squares
sellWatch1 = (usePriceBandWatchSignals) and (priceCrossUnderInner and not rsiCrossUnderUpper) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
sellWatch2 = (useRsiWatchSignals) and (rsiCrossUnderUpper and not priceCrossUnderInner) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
sellWatch3 = (usePriceBandWatchSignals) and (priceCrossUnderInner and rsiCrossUnderUpper) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
sellWatch4 = (usePriceBandWatchSignals) and (priceCrossUnderInner) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
sellWatch5 = (useRsiWatchSignals) and (rsiCrossUnderUpper) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
sellWatch6 = (useRsiWatchSignals) and (rsiCrossUnder75) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
sellWatch7 = (useAtrWatchSignals) and (lowOverAtrUpper) and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)
//sellWatch8 = (useThresholdCrosses) and (ta.crossunder(distance, volatilityThreshold))  and (barstate.isconfirmed) and (not watchesInsideYellowRsi) and (not signalsBlocked)

bool buyWatched = buyWatch1 or buyWatch2 or buyWatch3 or buyWatch4 or buyWatch5 or buyWatch6 or buyWatch7 // or buyWatch8
bool sellWatched = sellWatch1 or sellWatch2 or sellWatch3 or sellWatch4 or sellWatch5 or sellWatch6 or sellWatch7 // or sellWatch8

// Buy signals
buySignal1 = (useRsiSignals and rsiCrossOverBasis)
buySignal2 = (usePriceSignals and priceCrossOverBasis)
buySignal3 = (use50Signals and rsiCrossOver50)
buySignal4 = (use25Signals and rsiCrossOver25)
buySignal5 = (useMacdSignals and macdBuy)
buySignal6 = (useRsiMa and rsiCrossOverMa)
//buySignal7 = (useAdjustedRsi and adjustedRsiCrossOverBasis)
//buySignal8 = (useAdjustedRsi and adjustedRsiCrossOverMa)

// Sell signals
sellSignal1 = (useRsiSignals and rsiCrossUnderBasis)
sellSignal2 = (use50Signals and rsiCrossUnder50)
sellSignal3 = (usePriceSignals and priceCrossUnderBasis)
sellSignal4 = (use75Signals and rsiCrossUnder75)
sellSignal5 = (useMacdSignals and macdSell)
sellSignal6 = (useRsiMa and rsiCrossUnderMa)
//sellSignal7 = (useAdjustedRsi and adjustedRsiCrossUnderBasis)
//sellSignal8 = (useAdjustedRsi and adjustedRsiCrossUnderMa)


/////////////////////////
// Watch Signal Arrays //
/////////////////////////

array.push(buyWatchArray, buyWatched ? 1 : na)
array.push(sellWatchArray, sellWatched ? 1 : na)

while array.size(buyWatchArray) > watchSignalLookback
    array.shift(buyWatchArray)
while array.size(sellWatchArray) > watchSignalLookback
    array.shift(sellWatchArray)

buyWatchSumMet = (array.sum(buyWatchArray) >= 1) 
sellWatchSumMet = (array.sum(sellWatchArray) >= 1) 

buyWatchMet = (buyWatchSumMet)
sellWatchMet = (sellWatchSumMet)

combinedBuySignals = buySignal1 or buySignal2 or buySignal3 or buySignal4 or buySignal5 or buySignal6 // or buySignal7 or buySignal8
combinedSellSignals = sellSignal1 or sellSignal2 or sellSignal3 or sellSignal4 or sellSignal5 or sellSignal6 // or sellSignal7 or sellSignal8

// Use buyWatchRequired and sellWatchRequired here for generating buy and sell signals
buySignals = ((not requireWatchSignals and combinedBuySignals) or (requireWatchSignals and buyWatchMet and combinedBuySignals))
sellSignals = ((not requireWatchSignals and combinedSellSignals) or (requireWatchSignals and sellWatchMet and combinedSellSignals))

////////////////////////
// Buy and Sell logic //
////////////////////////

if (buySignals) and (not buyAndSellInsideYellowRsi) and (not buyWatched) and (not signalsBlocked) and ((dpoAllowBuy) and (rocAllowBuy))
    plotBuyBG := true
else if (sellSignals) and (not buyAndSellInsideYellowRsi) and (not sellWatched) and (not signalsBlocked) and ((dpoAllowSell) and (rocAllowSell))
    plotSellBG := true
else 
    plotBuyBG := false
    plotSellBG := false

if (buySignals) and (barstate.isconfirmed) and (not buyAndSellInsideYellowRsi) and (not buyWatched) and (not signalsBlocked) and ((dpoAllowBuy) and (rocAllowBuy))
    bought := true
    sold := false
    plotBuy := true
    lastSignalBarIndex := bar_index
    array.clear(buyWatchArray)
    array.clear(sellWatchArray)
else if (sellSignals) and (barstate.isconfirmed) and (not buyAndSellInsideYellowRsi) and (not sellWatched) and (not signalsBlocked) and ((dpoAllowSell) and (rocAllowSell))
    sold := true
    bought := false
    plotSell := true
    lastSignalBarIndex := bar_index
    array.clear(sellWatchArray)
    array.clear(buyWatchArray)
else 
    plotBuy := false
    plotSell := false

// Buy and sell signal alerts (Advanced or final)
alertcondition(enableAdvancedAlerts ? plotBuyBG : plotBuy, title='Buy signal', message='Buy signal detected')
alertcondition(enableAdvancedAlerts ? plotSellBG : plotSell, title='Sell signal', message='Sell signal detected')

// Check if the current bar is within the wait period after a buy or sell signal
if useSignalWaiting
    signalsBlocked := na(lastSignalBarIndex) == false and bar_index - lastSignalBarIndex <= signalWaitPeriod
else
    signalsBlocked := false

// Buy and Sell Signal triangles and labels
plotshape(showSignals and plotBuy ? true : na, title="BUY/LONG", location=location.belowbar, color=color.new(color.orange,0), style=shape.triangleup, textcolor=color.orange, text="B", size=size.tiny)
plotshape(showSignals and plotSell ? true : na, title="SELL/SHORT", location=location.abovebar, color=color.new(color.fuchsia,0), style=shape.triangledown, textcolor=color.fuchsia, text="S", size=size.tiny)
// Buy Sell Warning Vertical Colored Background
bgcolor(showSignalBackground and plotBuyBG ? color.new(color.orange, 80) : na)
bgcolor(showSignalBackground and plotSellBG ? color.new(color.fuchsia, 80) : na)
// Buy circles
B1 = color.new(color.orange, 50) 
B2 = color.new(color.orange, 65)
B3 = color.new(color.orange, 85)
S1 = color.new(color.fuchsia, 50) 
S2 = color.new(color.fuchsia, 65)
S3 = color.new(color.fuchsia, 85)
plotshape(showSignals and showCircles and plotBuy ? low : na, color= B1, location=location.absolute, style=shape.circle, size=size.tiny)
plotshape(showSignals and showCircles and plotBuy ? low : na, color= B2, location=location.absolute, style=shape.circle, size=size.small)
plotshape(showSignals and showCircles and plotBuy ? low : na, color= B3, location=location.absolute, style=shape.circle, size=size.normal)
plotshape(showSignals and showCircles and plotSell ? high : na, color= S1, location=location.absolute, style=shape.circle, size=size.tiny)
plotshape(showSignals and showCircles and plotSell ? high : na, color= S2, location=location.absolute, style=shape.circle, size=size.small)
plotshape(showSignals and showCircles and plotSell ? high : na, color= S3, location=location.absolute, style=shape.circle, size=size.normal)
// Bought and sold state colored background
bgcolor(showBSBackground and bought ? color.new(color.green, 90) : na)
bgcolor(showBSBackground and sold ? color.new(color.red, 90) : na)

// Plot Buy Watch signals based on filters
plotshape(showWatchSignals and buyWatched and not signalsBlocked ? true : na, title="Buy Watch Signals", location=location.belowbar, color=color.new(color.orange, 20), style=shape.square, size=size.tiny)

// Plot Sell Watch signals based on filters
plotshape(showWatchSignals and sellWatched and not signalsBlocked ? true : na, title="Sell Watch Signals", location=location.abovebar, color=color.new(color.fuchsia, 20), style=shape.square, size=size.tiny)

////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// This section handles candle coloring based on RSI levels (option 1), DPO ribbon trend (option 2)     ///
/// as well as the color of the candles when there is a buy or sell signal (if turned on).               ///
/// NOTE: If DPO Candles are selected, the candles will be brighter when the Bollinger Bands are         ///
/// wider (higher volatility) and will darken when the Bollinger Bands are narrowing (lower volatility). ///
/// I added this feature so you can still visualize the volatility without having to clutter the screen  ///
/// with Bollinger Bands.                                                                                ///
////////////////////////////////////////////////////////////////////////////////////////////////////////////


// Ensure Mutual Exclusivity of Candle Coloring using ternary operators
showRSICandleColors := showRSICandleColors ? true : showDPOCandleColors ? false : showRSICandleColors
showDPOCandleColors := showDPOCandleColors ? true : showRSICandleColors ? false : showDPOCandleColors

// Define color zones
oneHundredTo85 = showRSICandleColors and smoothedRsi <= 100 and smoothedRsi >= 85
eightyFiveTo75 = showRSICandleColors and smoothedRsi < 85 and smoothedRsi >= 75
seventyFiveTo70 = showRSICandleColors and smoothedRsi < 75 and smoothedRsi >= 70
seventyTo65 = showRSICandleColors and smoothedRsi < 70 and smoothedRsi >= 65
sixtyFiveTo60 = showRSICandleColors and smoothedRsi < 65 and smoothedRsi >= 60
sixtyToYellowHigh = showRSICandleColors and smoothedRsi < 60 and smoothedRsi >= yellowRsiFilterHigh
yellowHighToYellowLow = showRSICandleColors and smoothedRsi < yellowRsiFilterHigh and smoothedRsi >= yellowRsiFilterLow
yellowLowTo40 = showRSICandleColors and smoothedRsi < yellowRsiFilterLow and smoothedRsi >= 40
fourtyTo35 = showRSICandleColors and smoothedRsi < 40 and smoothedRsi >= 35
thirtyFiveTo30 = showRSICandleColors and smoothedRsi < 35 and smoothedRsi >= 30
thirtyTo25 = showRSICandleColors and smoothedRsi < 30 and smoothedRsi >= 25
twentyFiveTo15 = showRSICandleColors and smoothedRsi < 25 and smoothedRsi >= 15
fifteenTo0 = showRSICandleColors and smoothedRsi < 15 and smoothedRsi >= 0

// Assign RSI-based colors
RsiCandleColor = oneHundredTo85 ? color.new(color.white, 20) : eightyFiveTo75 ? color.new(color.lime, 0) : seventyFiveTo70 ? color.new(color.lime, 15) : seventyTo65 ? color.new(color.green, 0) : sixtyFiveTo60 ? color.new(color.green, 15) : sixtyToYellowHigh ? color.new(color.green, 30) : yellowHighToYellowLow ? color.new(color.yellow, 30) : yellowLowTo40 ? color.new(color.red, 50) : fourtyTo35 ? color.new(color.red, 45) : thirtyFiveTo30 ? color.new(color.red, 30) : thirtyTo25 ? color.new(color.red, 15) : twentyFiveTo15 ? color.new(color.red, 0) : fifteenTo0 ? color.new(color.white, 20) : na 

// Candle color conditions for DPO
dpoCandleColor = showDPOCandleColors ? (dpoBullish ? color.new(upColor, band_transparency) : color.new(downColor, band_transparency)) : na

// Determine if the current candle is a buy or sell signal candle
buySignalCandle = showSignals and plotBuy
sellSignalCandle = showSignals and plotSell

// Determine the final candle color
CandleColor = buySignalCandle ? color.new(color.orange, 0) : sellSignalCandle ? color.new(color.fuchsia, 0) : showRSICandleColors ? RsiCandleColor : showDPOCandleColors ? dpoCandleColor : na

// Plot the candles with custom color for body, wick, and border
plotcandle(open, high, low, close, color=CandleColor, wickcolor=CandleColor, bordercolor=CandleColor)